---
title: "S1_Resolving_Power_Supplement"
author: Colin S. Beam
date: 
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
library(tidyverse)
library(kableExtra)
library(PRROC)
library(boot)
library(egg)
```

```{r}
# initialize figure and table numbers
fnum <- 1
tnum <- 1
eqnum <- 1
footnote_num <- 1

```

```{r plotting parameters}
# caption title size
caption_size <- 10

# legend text size
axis.text.x.size <- 12
legend.text.size <- 12

```


## Overview

This technical supplement contains all of the code used for the resolving power paper. Associated data files can also be found in the same directory. For questions please contact [Colin Beam](cbeam@ursahealth.com).

## 2. ROC and PR curves

```{r confusion matrix}
confusion_matrix <- matrix(nrow = 3, ncol=2)
colnames(confusion_matrix) <- c("actual +", "actual -")
rownames(confusion_matrix) <- c("predicted +", "predicted -", "total")

confusion_matrix[1,] <- c("TP", "FP")
confusion_matrix[2,] <- c("FN", "TN")
confusion_matrix[3,] <- c("P", "N")

figure_title <- paste0("Figure ", fnum, ". An example confusion matrix")

kableExtra::kbl(confusion_matrix) %>% 
  kable_styling(bootstrap_options = "bordered", full_width = F, position = "float_right") %>% 
  footnote(general_title="", general = figure_title, title_format = "italic") %>% 
  row_spec(0,bold=TRUE) %>% 
  column_spec(1, bold = TRUE)

fnum <- fnum+1  


```

## 3. Mapping between metrics

```{r men versus women height}
# source: https://ourworldindata.org/human-height

# parameters
male_mean <- 178.4
male_sd <- 186 - male_mean

female_mean <- 164.7
female_sd <- 171.8 - female_mean

# find implied auroc
delta_c <- male_mean - female_mean
auroc <- pnorm(delta_c/sqrt(male_sd^2 + female_sd^2))

# alternate calculation: standardize by female distribution
#male_standard_mean <- (male_mean - female_mean)/female_sd
#male_standard_sd <- male_sd/female_sd
#pnorm(male_standard_mean/sqrt(1^2 + male_standard_sd^2))

# probabilistic interpretation
#nsim <- 10000
#men_heights <- rnorm(n = nsim, mean = male_mean, sd = male_sd)
#women_heights <- rnorm(n = nsim, mean = female_mean, sd = female_sd)
#mean(men_heights > women_heights)

# threshold
decision_threshold <- 171

```

```{r binormal model graphs}
# female distribution
female_data <- data.frame(cm = seq(female_mean - 3*female_sd, female_mean + 4*female_sd, length.out=1000))

female_data <- female_data %>% 
  mutate(y = dnorm(cm, mean = female_mean, sd = female_sd),
         distribution = "Women")

# male distribution
male_data <- data.frame(cm = seq(male_mean - 4*male_sd, male_mean + 3*male_sd, length.out=1000))

male_data <- male_data %>% 
  mutate(y = dnorm(cm, mean = male_mean, sd = male_sd),
         distribution = "Men")

height_fnum <- fnum
plot_data <- bind_rows(female_data, male_data)

plot_title <- paste0("Figure ", height_fnum, ".", " Binormal classifier example. The distribution of men's and women's heights\nfollow approximately a normal distribution. The model implies an AUROC of .906.\nThe vertical dashed line at 171 cm is an example decision threshold.")

binormal_example <- ggplot(plot_data, aes(cm, y, color=distribution)) +
  geom_path() +
  geom_vline(xintercept = decision_threshold, linetype = "dashed") +
  #scale_linetype_manual(values = c("dashed", "solid")) +
  scale_color_manual(values = c("dodgerblue", "darkgoldenrod1")) +
  scale_x_continuous( breaks = c(164.7, 178.4) ) +
  theme_bw() +
  labs(
    #caption = plot_title, 
    x = "cm",
    y = "density",
    linetype="") +
  theme(
    plot.caption = element_text(hjust = 0, vjust = 0, size = caption_size),
    axis.text.x = element_text(size=axis.text.x.size),
    legend.title = element_blank()
    ) 

```


```{r mapping figure numbers}
# height figure
height_fnum <- fnum
fnum <- fnum + 1

```


## 4. Resolving power

```{r fictional response functions}
#----
# auroc_to_ausgc
#
# For a given model AUROC and prevalence, give the AUSGC.
#
## arguments
# 
# auroc   model auroc
# v       prevalence of the positive class
#
auroc_to_ausgc <- function(auroc, v) {
  x <- (auroc - 0.5)/0.5  # map to 0-1 scale.
  beta0 <- log(v)
  beta1 <- -log(v)
  log_ausgc <-  beta0 + beta1*x
  ausgc <- exp(log_ausgc)
  ausgc
}


#----
# ausgc_to_auroc
#
# For a given model AUSGC and prevalence, give the AUSGC 
#
## arguments
# 
# ausgc   ausgc of the model
# v       prevalence of the model
ausgc_to_auroc <- function(ausgc, v) {
  beta0 <- log(v)
  beta1 <- -log(v)
  percentile <- ( log(ausgc) - beta0 )/(beta1)
  auroc <- 0.5*percentile + 0.5
  auroc
}



```


```{r metric comparison data}
#----
# Model compare data
prevalence <- 0.01
eps <- rep(c(.05, .05), each=2)

metric_label <- rep(c("AUROC", "AUSGC"), each=2)
model_label <- rep(c("A", "B"), times=2)

auroc_eval <- c(0.7, 0.9)
metric <- c(auroc_eval, auroc_to_ausgc(auroc_eval, v = prevalence))
metric_lower <- metric - eps
metric_upper <- metric + eps

auroc_lower <- c(metric_lower[1:2], ausgc_to_auroc(metric_lower[3:4], v = prevalence))

auroc_upper <- c(metric_upper[1:2], ausgc_to_auroc(metric_upper[3:4], v = prevalence))

perf_data <- data.frame(
  metric_label = metric_label,
  model=model_label,
  auroc_eval=rep(auroc_eval, times=2),
  metric_value=metric,
  metric_lower=metric_lower,
  metric_upper=metric_upper,
  auroc_lower=auroc_lower,
  auroc_upper=auroc_upper
) %>% 
  mutate(
    metric_label = factor(metric_label, levels = c("AUROC", "AUSGC"))
  )



```


```{r create data for method example}
mcolors <- c("deepskyblue", "orange")
grid_length <- 1000
point_size <- 2
bar_size <- .03

auroc_quality <- seq(0.5, 1, length.out=grid_length)
m1 <- auroc_quality
m2 <- auroc_to_ausgc(auroc_quality, v = prevalence)

metric_label <- rep(c("AUROC", "AUSGC"), each=grid_length)

metric_data <- data.frame(
  metric_label = metric_label,
  auroc = rep(auroc_quality, 2),
  metric_value = c(m1, m2)
  ) %>% 
  mutate(
    metric_label = factor(metric_label, levels = c("AUROC", "AUSGC"))
  )


```


```{r create AUROC 0.7 plot}
auroc_select <- 0.7

# perf data for only xth percentile
plot_data <- perf_data %>% 
  filter(auroc_eval==auroc_select) 

# ROC line segments
roc_lower_y <- plot_data$metric_lower[plot_data$metric_label=="AUROC"]
roc_lower_x2 <- roc_lower_y
roc_upper_y <- plot_data$metric_upper[plot_data$metric_label=="AUROC"]
roc_upper_x2 <- roc_upper_y


# SG line segments
sg_lower_y <- plot_data$metric_lower[plot_data$metric_label=="AUSGC"]
sg_lower_x2 <- ausgc_to_auroc(sg_lower_y, v = prevalence)
sg_upper_y <- plot_data$metric_upper[plot_data$metric_label=="AUSGC"]
sg_upper_x2 <- ausgc_to_auroc(sg_upper_y, v = prevalence)


# line segment data
segment_data <- data.frame(
  metric_label = c("AUROC", "AUSGC"),
  x1 = c(auroc_select, auroc_select),
  lower_y = c(roc_lower_y, sg_lower_y),
  lower_x2 = c(roc_lower_x2, sg_lower_x2),
  upper_y = c(roc_upper_y, sg_upper_y),
  upper_x2 = c(roc_upper_x2, sg_upper_x2)
) %>% 
  mutate(
    metric_label = factor(metric_label, levels=c("AUROC", "AUSGC"))
  )


####
# CI plot
ci_plot <- ggplot(metric_data, aes(auroc, metric_value)) +
  facet_wrap(~ metric_label, ncol=2) +
  geom_path(color="black") +
  xlab("AUROC model quality") +
  ylab("Metric value") +
  geom_point(mapping = aes(auroc_eval, metric_value), data = plot_data, size=point_size, color=mcolors[1]) +
  geom_errorbar(mapping = aes(auroc_eval, ymin=metric_lower, ymax=metric_upper), data = plot_data, width=bar_size, color=mcolors[1]) +
  geom_segment(aes(x = x1, y = lower_y, xend = lower_x2, yend = lower_y), data = segment_data, color=mcolors[1], linetype="dashed") +
  geom_segment(aes(x = lower_x2, y = lower_y, xend = lower_x2, yend = -Inf), data = segment_data, color=mcolors[1], linetype="dashed") +
  geom_segment(aes(x = x1, y = upper_y, xend = upper_x2, yend = upper_y), data = segment_data, color=mcolors[1], linetype="dashed") +
  geom_segment(aes(x = upper_x2, y = upper_y, xend = upper_x2, yend = -Inf), data = segment_data, color=mcolors[1], linetype="dashed") +
  theme_bw() +
  NULL


```


```{r create AUROC 0.9 plot}
auroc_select <- 0.9

# perf data for only xth percentile
plot_data <- perf_data %>% 
  filter(auroc_eval==auroc_select) 

# ROC line segments
roc_lower_y <- plot_data$metric_lower[plot_data$metric_label=="AUROC"]
roc_lower_x2 <- roc_lower_y
roc_upper_y <- plot_data$metric_upper[plot_data$metric_label=="AUROC"]
roc_upper_x2 <- roc_upper_y


# SG line segments
sg_lower_y <- plot_data$metric_lower[plot_data$metric_label=="AUSGC"]
sg_lower_x2 <- ausgc_to_auroc(sg_lower_y, v = prevalence)
sg_upper_y <- plot_data$metric_upper[plot_data$metric_label=="AUSGC"]
sg_upper_x2 <- ausgc_to_auroc(sg_upper_y, v = prevalence)


# line segment data
segment_data <- data.frame(
  metric_label = c("AUROC", "AUSGC"),
  x1 = c(auroc_select, auroc_select),
  lower_y = c(roc_lower_y, sg_lower_y),
  lower_x2 = c(roc_lower_x2, sg_lower_x2),
  upper_y = c(roc_upper_y, sg_upper_y),
  upper_x2 = c(roc_upper_x2, sg_upper_x2)
) %>% 
  mutate(
    metric_label = factor(metric_label, levels=c("AUROC", "AUSGC"))
  )



####
# CI plot

ci_plot <- ci_plot +
  geom_point(mapping = aes(auroc_eval, metric_value), data = plot_data, size=point_size, color=mcolors[2]) +
  geom_errorbar(mapping = aes(auroc_eval, ymin=metric_lower, ymax=metric_upper), data = plot_data, width=bar_size, color=mcolors[2]) +
  geom_segment(aes(x = x1, y = lower_y, xend = lower_x2, yend = lower_y), data = segment_data, color=mcolors[2], linetype="dashed") +
  geom_segment(aes(x = lower_x2, y = lower_y, xend = lower_x2, yend = -Inf), data = segment_data, color=mcolors[2], linetype="dashed") +
  geom_segment(aes(x = x1, y = upper_y, xend = upper_x2, yend = upper_y), data = segment_data, color=mcolors[2], linetype="dashed") +
  geom_segment(aes(x = upper_x2, y = upper_y, xend = upper_x2, yend = -Inf), data = segment_data, color=mcolors[2], linetype="dashed") +
  #labs(caption = ci_title) +
  theme_bw() +
  theme(plot.caption = element_text(hjust = 0, vjust = 0, size = caption_size)) +
  NULL


```

```{r Resolving power figure numbers}
# confidence interval plot
ci_fnum <- fnum
fnum <- fnum+1

```


## 5. Binormal model


```{r gaussian PRC curve}
#-----
# binormal_ppv
#
# Gives PPV at a given TPR assuming positive scores are drawn from a N(mu1, 1) distribution and negative scores drawn from a N(0, 1) distribution.
#
## Arguments
#
# tpr       true positive rate. Ranges from 0 to 1
# alpha     prevalence
# mu1       mean of the positive class
#
# Notes: This function assume standard normal distributions with equal variances and the negative class centered at zero. See Brodersen et al. for a more general formulation.

binormal_ppv <- function(tpr, alpha, mu1) {
  ppv <- (alpha*tpr)/(alpha*tpr + (1-alpha)*( 1- pnorm(qnorm(1-tpr, mean = mu1))))
  ppv
}

#-----
# binormal_auprc
#
# Use numerical integration to calculate AUPRC for positive scores drawn from a N(mu1, 1) distribution and negative scores drawn from a N(0, 1) distribution.
#
## Arguments
#
# auroc     auroc to determine distance between the two distributions
# alpha     prevalence
# nsim      number of grid points for numerical integration
#
binormal_auprc <- function(auroc, alpha, nsim=1000) {
  
  # find shift parameter
  mu1 <- sqrt(2)*qnorm(auroc)
  
  # tpr sequence
  tpr <- seq(1/nsim, 1, length.out=nsim)
  
  # find average precision
  auprc <- mean(binormal_ppv(tpr = tpr, alpha = alpha, mu1 = mu1))
  auprc
    
}

```


```{r approximate AUPRC across grid using binormal model, eval=FALSE}
# form tuning grid
prevalence <- c(.01, .05, .10, .20, .30, .40, .50)
auroc_values <- seq(0.5, .99995, length.out = 10000)

tune_grid <- expand.grid(auroc=auroc_values, prevalence=prevalence)

gauss_results <- data.frame(
  prevalence = tune_grid$prevalence,
  pop_auroc = tune_grid$auroc,
  aupr = NA
)

# array for apply function
auroc_values <- matrix(auroc_values, ncol = 1)

for(i in 1:length(prevalence) ) {
  
  # set parameters
  v <- prevalence[i]
  
  # estimate auprs
  new_aupr <- apply(auroc_values, 1, binormal_aupr, alpha=v)
  
  # store results
  gauss_results[gauss_results$prevalence==v, 3] <- new_aupr
  
}

# save results
write_csv(gauss_results, file = "gauss_aupr_grid.csv")

```


```{r functions for binormal simulation}
# overlap functions
source("./Functions/dist_overlap.R")

# binormal response curve
auprc_grid <- read_csv("gauss_auprc_grid.csv")

# functions to recover estimates
est_auroc <- function(scores, outcomes) {
  estimate <- PRROC::roc.curve(scores.class0 = scores, weights.class0 = outcomes)$auc
  estimate
}

est_auprc <- function(scores, outcomes) {
  estimate <- PRROC::pr.curve(scores.class0 = scores, weights.class0 = outcomes)$auc.davis.goadrich
  estimate
}

```


```{r binormal simulation study, eval=FALSE}
# number of repeats
nrepeats <- 3

# number of simulations: limited by vector allocation size 
nsim <- 10000

# batches: number of packets to break up nsim
nbatches <- 1

set.seed(1)
# fix total number of cases or number of negative cases
N <- 1000

# check max vector allocation
if (nsim*N/nbatches > 1e+08) {
  stop("Cannot allocate vector of that size. Try increasing the number of batches/reducing the batch size.")
}

# set uncertainty interval range
CIrange <- 0.95

# simulation parameters
prevalence <- c(.01, .05, .10, .20, .30, .40, .50)
pop_auroc <- c(0.65, 0.75, 0.85, 0.95)

sim_grid <- expand.grid(pop_auroc, prevalence)
names(sim_grid) <- c("pop_auroc", "prevalence")

# bootstrap data store
gauss_results <- data.frame(
  nrepeat = NA,
  prevalence = sim_grid$prevalence,
  pop_auroc = sim_grid$pop_auroc,
  roc_est = NA,
  roc_est_lower = NA,
  roc_est_upper = NA,
  pr_est = NA,
  pr_est_lower = NA,
  pr_est_upper = NA
)

# placeholder to store each repeat
gauss_store <- data.frame(
  nrepeat = NA,
  prevalence = NA,
  pop_auroc = NA,
  roc_est = NA,
  roc_est_lower = NA,
  roc_est_upper = NA,
  pr_est = NA,
  pr_est_lower = NA,
  pr_est_upper = NA
)


start <- Sys.time()

for (nr in 1:nrepeats) {
  
  counter <- 1
  
  for (v in prevalence) {
    
    for (pa in pop_auroc) {
      
      nsize <- nsim/nbatches
      aurocs <- NULL; auprcs <- NULL
      
      for(nb in 1:nbatches) {
        
        # apply prevalence
        #n_ones <- round(n_zeros*v/(1-v))
        n_ones <- round(v*N)
        n_zeros <- N - n_ones
        
        # simulation outcome vector
        new_outcome = c(rep(1, n_ones), rep(0, n_zeros))
        
        # simulate values
        model_vecs <- gauss_overlap(auroc = pa, 
                                    n_ones = nsize*n_ones, 
                                    n_zeros = nsize*n_zeros)
        
        one_scores <- model_vecs[model_vecs$outcome==1,2] %>% 
          matrix(ncol = nsize) %>% 
          as.data.frame()
        
        zero_scores <- model_vecs[model_vecs$outcome==0,2] %>% 
          matrix(ncol = nsize) %>% 
          as.data.frame()
        
        new_scores <- bind_rows(one_scores, zero_scores)
        
        # find estimates
        new_aurocs <- apply(new_scores, 2, est_auroc, outcomes = new_outcome)
        new_auprcs <- apply(new_scores, 2, est_auprc, outcomes = new_outcome)
        
        # store estimates
        aurocs <- c(aurocs, new_aurocs)
        auprcs <- c(auprcs, new_auprcs)
        
      }
      
      # expectations
      E_roc <- mean(aurocs)
      E_pr <- mean(auprcs)
      
      # uncertainty intervals
      alpha_one_side <- (1 - CIrange)/2
      lower_quantile = alpha_one_side; upper_quantile = 1 - alpha_one_side
      ci_roc <- quantile(aurocs, probs = c(lower_quantile, upper_quantile))
      ci_pr <- quantile(auprcs, probs = c(lower_quantile, upper_quantile))
      
      # store results
      gauss_results[counter, -c(1,2,3)] <- c(E_roc, c(ci_roc), E_pr, c(ci_pr))
      
      cat(paste(counter, "\n"))
      counter <- counter+1
    }
    
  }
  
  gauss_results$nrepeat <- nr
  gauss_store <- bind_rows(gauss_store, gauss_results)
  
}

end <- Sys.time()
end - start

gauss_store <- gauss_store[-1,]

write_csv(gauss_store, file = paste0("gauss_", N, "N_", nsim, "nsim_", nrepeats, "nrepeats.csv"))


```


```{r map auprc to auroc}
#-----
# auprc_to_auroc
#
# For a given AUPRC score, find the corresponding auroc score from the function approximation.
auprc_to_auroc <- function(auprc, grid_fun) {
  
  out <- NULL
  
  for (pr in auprc) {
    closest_ind <- which.min(abs(100*pr - 100*grid_fun$auprc))
    pr_auroc <- grid_fun$pop_auroc[closest_ind]
    out <- c(out, pr_auroc)
  }
  
  out
}

```


```{r N10k simulation data}
# read-in data
gauss_store <- read_csv("gauss_10000N_10000nsim_3nrepeats.csv")

# find average estimates across runs
gauss_results <- gauss_store %>%
  group_by(prevalence, pop_auroc) %>% 
  summarise(across(everything(), ~mean(.x)) ) %>% 
  select(-nrepeat)

# add population auprc to results
auprc_key <- auprc_grid %>% 
  unite(col = "prev_auroc", prevalence:pop_auroc, sep="_") 

gauss_results <- gauss_results %>% 
  unite(col = "prev_auroc", prevalence:pop_auroc, sep="_", remove=FALSE)

gauss_results <- left_join(gauss_results, auprc_key, "prev_auroc") %>% 
  select(-prev_auroc) %>% 
  rename(pop_auprc = auprc) %>% 
  relocate(pop_auprc, .before = pr_est)

# map auprc to auroc
prevalence <- unique(gauss_results$prevalence)
pr_mean <- NULL
pr_lower <- NULL
pr_upper <- NULL

for(v in prevalence) {
  
  grid_fun <- auprc_grid %>% 
    filter(prevalence==v)
  
  # auprc to auroc: note that it is only to 4-decimal places of precision since grid contains 1000 points
  new_mean <- auprc_to_auroc(gauss_results$pr_est[gauss_results$prevalence==v], grid_fun = grid_fun)
  new_lower <- auprc_to_auroc(gauss_results$pr_est_lower[gauss_results$prevalence==v], grid_fun = grid_fun)
  new_upper <- auprc_to_auroc(gauss_results$pr_est_upper[gauss_results$prevalence==v], grid_fun = grid_fun)
  
  pr_mean <- c(pr_mean, new_mean)
  pr_lower <- c(pr_lower, new_lower)
  pr_upper <- c(pr_upper, new_upper)
  
}

# append to main grid
gauss_results$pr_est_roc <- pr_mean
gauss_results$pr_lower_roc <- pr_lower
gauss_results$pr_upper_roc <- pr_upper

# create data for plotting
plot_data <- gauss_results %>% 
  mutate(
    auroc_bias = roc_est - pop_auroc,
    auprc_bias = pr_est - pop_auprc,
    auprc_roc_bias = pr_est_roc - pop_auroc,
    auroc_CI_width = roc_est_upper - roc_est_lower, 
    auprc_CI_width = pr_upper_roc - pr_lower_roc,
    width_delta = auprc_CI_width - auroc_CI_width
  ) %>% 
  select(
    prevalence,
    pop_auroc,
    #auroc_bias,
    #auprc_bias,
    #auprc_roc_bias,
    roc_est_lower,
    roc_est_upper,
    pr_lower_roc,
    pr_upper_roc,
    auroc_CI_width,
    auprc_CI_width,
    width_delta
  ) %>% 
  mutate(
    # Use the Hosmer & Lemeshow rule of thumb: https://imaging.mrc-cbu.cam.ac.uk/statswiki/FAQ/roc
    model_quality = case_when(
      pop_auroc==.65 ~ "Poor",
      pop_auroc==.75 ~ "Fair",
      pop_auroc==.85 ~ "Good",
      pop_auroc==.95 ~ "Excellent"
    ),
    model_quality = factor(model_quality, levels = c("Poor", "Fair", "Good", "Excellent")),
    prevalence = factor(prevalence),
    ci_ratio = auprc_CI_width/auroc_CI_width - 1
  )

  

```


```{r N10k relative comparison plot}
pop_auroc <- unique(plot_data$pop_auroc)

plot_relative <- ggplot(plot_data, aes(prevalence, ci_ratio, fill=prevalence)) +
  facet_wrap( ~ model_quality, nrow = 1) +
  geom_col() +
  scale_x_discrete(labels = c(".01", ".05", ".10", ".20", ".30", ".40", ".50")) +
  ylab(~ paste(kappa["PRC"], "/", kappa["ROC"], " - 1")) +
  theme_bw()


```


```{r auc_ci function, include=FALSE}
#----
# se_auc
#
# Standard error for the area under the empirical ROC curve.
#
## Arguments
#
# theta           the population AUROC value
# n1              number of positive cases
# n0              number of negative cases
#
# References: See Hanley and McNeil 1982

se_auc <- function(theta, n1, n0) {
  
  # assume negative exponential model for these quantities:
  q1 <- theta/(2 - theta)
  q2 <- 2*theta^2/(1 + theta)
  
  se_w <- sqrt(
    (theta*(1 - theta) + (n1 - 1)*(q1 - theta^2) + (n0 - 1)*(q2 - theta^2))/(n1*n0)
  )
  
  se_w
  
}

```


```{r data for AUROC SE plot}
# add large sample, normal approximation CIs to grid
N <- 10000
n1 <- N*auprc_grid$prevalence
n0 <- N - n1

SE_data <- se_auc(theta = auprc_grid$pop_auroc, n1 = n1, n0 = n0)
auprc_grid$SE_AUROC <- SE_data


```


```{r AUPRC response curve plot}
# define prevalence as a factor
auprc_grid <- auprc_grid %>% 
  mutate(
    prevalence = factor(prevalence)
  )

# find slope for prevalence 0.5 curve
fit50 <- lm(auprc ~ pop_auroc, data = auprc_grid, subset = auprc_grid$prevalence=="0.5")

# construct data used for simulation
eval_data <- auprc_grid[round(auprc_grid$pop_auroc,5) %in% pop_auroc, ]

eval_data <- eval_data %>% 
  mutate(
    pop_auroc = round(pop_auroc,5),
    model_quality = case_when(
      pop_auroc==.65 ~ "Poor",
      pop_auroc==.75 ~ "Fair",
      pop_auroc==.85 ~ "Good",
      pop_auroc==.95 ~ "Excellent"
    ),
    model_quality = factor(model_quality, levels = c("Poor", "Fair", "Good", "Excellent"))
    )

gauss_RC <- ggplot(auprc_grid, aes(pop_auroc, auprc, color=prevalence)) + 
  geom_path() +
  geom_point(data = eval_data, aes(pop_auroc, auprc, shape=model_quality), size=2) +
  xlab("AUROC") +
  ylab("AUPRC") +
  #labs(caption = plot_title) +
  theme_bw() +
  theme(
    plot.caption = element_text(hjust = 0, vjust = 0, size = caption_size),
    legend.box = "horizontal")

```


```{r  AUROC resolving power plot}
# power plot data: limit AUROC range
#power_data <- auprc_grid %>%  
#  filter(pop_auroc <= .95) %>%
#  mutate(
#    prevalence = factor(prevalence)
#  )

SE_plot <- ggplot(auprc_grid, aes(pop_auroc, SE_AUROC, color=prevalence)) + 
  geom_path() +
  xlab("AUROC") +
  ylab("Standard Error") +
  #labs(caption = plot_title) +
  theme_bw() +
  theme(
    plot.caption = element_text(hjust = 0, vjust = 0, size = caption_size),
    legend.box = "horizontal")

####
# normal approximate CIs

zstat <- qnorm(1-.05/2)
N <- 10000

# AUROC = .65 and prevalence = .01
theta <- 0.65
prev <- .01
n1 <- prev*N
n0 <- N - n1

# normal approx CI
condition_SE <- se_auc(theta, n1, n0)
normal_auroc65CI <- c(theta - zstat*condition_SE, theta + zstat*condition_SE)

# simulation CI
sim_auroc65CI <- plot_data %>% 
  filter(prevalence == as.character(prev), pop_auroc==theta)

sim_auroc65CI <- c(sim_auroc65CI$roc_est_lower, sim_auroc65CI$roc_est_upper)


# AUROC = .95 and prevalence = .01
theta <- 0.95
prev <- .01
n1 <- prev*N
n0 <- N - n1

# normal approx CI
condition_SE <- se_auc(theta, n1, n0)
normal_auroc95CI <- c(theta - zstat*condition_SE, theta + zstat*condition_SE)

# simulation CI
sim_auroc95CI <- plot_data %>% 
  filter(prevalence == as.character(prev), pop_auroc==theta)

sim_auroc95CI <- c(sim_auroc95CI$roc_est_lower, sim_auroc95CI$roc_est_upper)


```

```{r binormal section figure numbers}
# simulation design plot
gauss_fnum <- fnum
fnum <- fnum + 1

# relative resolving power plot
N10k_rel_fnum <- fnum
fnum <- fnum+1

# standard error plot
SE_plot_fnum <- fnum
fnum <- fnum + 1

```


## 6. Empirical sampling models

```{r import data}
# see source folder for scripts that built this data set
load("C:/Users/ColinBeam/OneDrive - Ursa Health/Documents/Colin_UrsaFiles/Ursa Projects/Standard_Models/preventable_utilization/diabetes_example/diabetes_post_raw.RData")

```

```{r prep data for XGBoost}
# separate ID
patient_nbr <- dataset %>% 
  select(patient_nbr)

# select outcome
dataset <- dataset %>% 
  rename(
    DV = outcome
  ) %>%
  mutate(
    DV = ifelse(DV=="readmitted", 1, 0)
  ) %>% 
  select(
    -patient_nbr,
  ) %>% 
  relocate(DV)

# remove DV for R code
DV <- dataset$DV
dataset <- select(dataset, -DV)

```

```{r create model matrix}
# use caret functions
library(caret)
dmy <- dummyVars( ~ ., data = dataset, fullRank = TRUE)
mod_mat <- predict(dmy, newdata = dataset)

```

```{r 5-fold data splitting, include=FALSE}
library(caret)

set.seed(1)
kfolds <- 5
fold_list <- createFolds(as.factor(DV), k = kfolds)

# check the number of events per fold: want about 100.
for(j in 1:length(fold_list)) {
  print(sum(DV[fold_list[[j]]]))
}

```

```{r, include=FALSE}
###
# cross-validation

# store test results
test_results <- data.frame(DV=NA, ylogit=NA)

for(kf in 1:kfolds) {
  
  # cross-validation
  next_test <- kf
  next_train <- setdiff(1:kfolds, kf)
  
  train_index <- unlist(fold_list[next_train])
  test_index <- unlist(fold_list[next_test])
  
  ###
  # train model
  
  # training data
  train_mat <- mod_mat[train_index,]
  train_DV <- DV[train_index]
  train_data <- cbind(train_DV, train_mat) %>% 
    as.data.frame()
  
  glm_mod <- glm(train_DV ~ ., data = train_data, family = binomial())
  
  ###
  # test results
  
  # test data
  test_mat <- mod_mat[test_index,]
  test_DV <- DV[test_index]
  test_data <- as.data.frame(test_mat)
  
  ylogit <- predict(glm_mod, newdata = test_data)
  
  # store results 
  new_results <- data.frame(DV = test_DV, ylogit = ylogit)
  test_results <- bind_rows(test_results, new_results)
  cat("*")
  
}

test_results <- test_results[-1,]

test_results <- test_results %>% 
  mutate(
    class = ifelse(DV==1, "positive", "negative"),
    class = factor(class, levels = c("negative", "positive"))
  )

```

```{r descriptive statistics}
# prevalence
readmit_prevalence <- mean(test_results$DV)

# average logit in each group
test_summary <- test_results %>% 
  mutate(
    est_prob = boot::inv.logit(ylogit)
  ) %>% 
  group_by(class) %>% 
  summarise(
    Npats = n(),
    mean_logit = mean(ylogit),
    sd_logit = sd(ylogit),
    mean_prob = mean(est_prob)
  )

# Sample AUROC
test_auroc <- PRROC::roc.curve(scores.class0 = test_results$ylogit, weights.class0 = test_results$DV)

# Sample AUPRC
test_auprc <- PRROC::pr.curve(scores.class0 = test_results$ylogit, weights.class0 = test_results$DV)


```


```{r plot logit distributions}
#-----
# risk distribution plot
lcolors <- c("dodgerblue", "darkgoldenrod1")

logit_distribution <- ggplot(test_results, aes(ylogit, color=class)) +
  geom_density() + 
  geom_rug(data = subset(test_results, DV==1), sides = "t", alpha=2/5) +
  geom_rug(data = subset(test_results, DV==0), sides = "b", alpha=2/5) +
  scale_color_manual(values = lcolors) +
  labs(
    y = "density",
    x = "estimated logit",
    color = "class"
  ) +
  theme_bw()

```


```{r qqnorm plots}
qq_distribution <- ggplot(test_results, aes(sample=ylogit, color=class)) +
  facet_grid(~class) +
  stat_qq() +
  stat_qq_line() +
  scale_color_manual(values = lcolors) +
  labs(x = "theoretical", y="sample") +
  theme_bw()
  
```


```{r step 1 create baseline model}
# set-up baseline model
baseline_model <- test_results %>% 
  select(
    outcome = DV,
    risk_score = ylogit,
  ) %>% 
  arrange(
    desc(risk_score)
  )

```


```{r step 2 grid formation}
#----
# build grid function
#
# Function to build response curve grid from a baseline model
#
## Arguments
# 
# baseline_model    empirical distribution of effects from a baseline model
# auroc_pos         auroc grid distance above baseline
# auroc_neg         auroc grid distance below baseline
# one_auroc_step    grid step size in auroc units
# exact_shift       find exact distribution shift at each step? currently only finds exact step for first step.

build_grid <- function(baseline_model, auroc_pos=.2, auroc_neg=.1, one_auroc_step=.001, exact_shift=FALSE) {
  
  # positive and negative effects from the baseline model
  pos_effects <- baseline_model$risk_score[baseline_model$outcome==1]
  neg_effects <- baseline_model$risk_score[baseline_model$outcome==0]
  
  # find the total number of adjacent switches
  n_pos <- sum(baseline_model$outcome) 
  n_neg <- nrow(baseline_model) - n_pos
  total_switches <- n_pos*n_neg
  
  # number of switches for one increment of auroc
  one_step_switches <- total_switches*one_auroc_step
  
  # grid steps in positive and negative direction
  pos_steps <- auroc_pos/one_auroc_step + 1
  neg_steps <- auroc_neg/one_auroc_step + 1
  
  # outer-product distance matrix
  # negative difference means "out-of-order" 
  # positive difference means "in-order"
  dist_mat <- outer(pos_effects, neg_effects, FUN = "-")
  
  ####
  # positive direction grid
  
  # shift to achieve number_switches in the positive direction
  out_of_order <- sort(-1*dist_mat[dist_mat<0], decreasing=FALSE)
  logit_shift <- out_of_order[one_step_switches]
  
  # start grid at baseline
  pos_grid <- data.frame(steps=1:pos_steps, auroc=NA, auprc=NA)
  
  shift_model <- baseline_model
  
  for(i in 1:pos_steps) {
    
    # calculate  and store auroc and auprc
    auroc <- PRROC::roc.curve(scores.class0 = shift_model$risk_score, weights.class0 = shift_model$outcome)$auc
    
    auprc <- PRROC::pr.curve(scores.class0 = shift_model$risk_score, weights.class0 = shift_model$outcome)$auc.davis.goadrich
    
    pos_grid[i,-1] <- c(auroc, auprc)  
    
    # shift grid by adding to positive class
    shift_model$risk_score[shift_model$outcome==1] <- shift_model$risk_score[shift_model$outcome==1] + logit_shift
    
    # if exact, find the updated distance
    # will be computationally expensive so probably not worth it
    if(exact_shift) {stop("feature not implemented")}
    
  }
  
  ####
  # negative direction grid
  
  # shift to achieve number_switches in the negative direction
  out_of_order <- sort(dist_mat[dist_mat>0], decreasing=FALSE)
  logit_shift <- out_of_order[one_step_switches]
  
  # start grid at baseline
  neg_grid <- data.frame(steps=1:neg_steps, auroc=NA, auprc=NA)
  
  shift_model <- baseline_model
  
  for(i in 1:neg_steps) {
    
    # calculate  and store auroc and auprc
    auroc <- PRROC::roc.curve(scores.class0 = shift_model$risk_score, weights.class0 = shift_model$outcome)$auc
    
    auprc <- PRROC::pr.curve(scores.class0 = shift_model$risk_score, weights.class0 = shift_model$outcome)$auc.davis.goadrich
    
    neg_grid[i,-1] <- c(auroc, auprc)  
    
    # shift grid by adding to positive class
    shift_model$risk_score[shift_model$outcome==1] <- shift_model$risk_score[shift_model$outcome==1] - logit_shift
    
    # if exact, find the updated distance
    # will be computationally expensive so probably not worth it
    if(exact_shift) {stop("feature not implemented")}
    
  }
  
  # create final grid
  neg_grid <- neg_grid[-1,]
  pos_grid <- arrange(pos_grid, desc(steps))
  
  model_grid <- bind_rows(pos_grid, neg_grid) %>% 
    select(-steps)
  
  model_grid
  
}


```


```{r form empirical grid, eval=FALSE}
empirical_grid <- build_grid(baseline_model = baseline_model, one_auroc_step = .0005, auroc_pos = 0.4, auroc_neg = 0.1)
write_csv(empirical_grid, "empirical_grid.csv")

```


```{r step 3 random sampling, eval=FALSE}
# indices for stratified sampling
row_index <- 1:nrow(baseline_model)
pos_index <- row_index[baseline_model$outcome==1]
neg_index <- setdiff(row_index, pos_index)

# apply stratified sampling to create bootstrap samples
nsim <- 10000
store_boot <- data.frame(sim = 1:nsim, auroc=NA, auprc=NA)

set.seed(1)
for(i in 1:nsim) {
  
  # stratified sampling
  pos_sample <- sample(pos_index, size = length(pos_index), replace = TRUE)
  neg_sample <- sample(neg_index, size = length(neg_index), replace = TRUE)
  
  boot_index <- c(pos_sample, neg_sample)
  boot_sample <- baseline_model[boot_index, ]
  
  # find metric values
  new_auroc <- PRROC::roc.curve(scores.class0 = boot_sample$risk_score, weights.class0 = boot_sample$outcome)$auc
  
  new_auprc <- PRROC::pr.curve(scores.class0 = boot_sample$risk_score, weights.class0 = boot_sample$outcome)$auc.davis.goadrich
  
  store_boot[i,-1] <- c(new_auroc, new_auprc)
  
}

write_csv(store_boot, file = "store_boot.csv")

```


```{r step 4 compare}
# import model grid
empirical_grid <- read_csv("empirical_grid.csv")

# import bootstrap data
store_boot <- read_csv("store_boot.csv")

# bootstrap bias
auroc_bias <- mean(store_boot$auroc) - test_auroc$auc
point_auprc <- mean(store_boot$auprc)
auprc_bias <- point_auprc - test_auprc$auc.davis.goadrich

# 95 percentile bootstrap interval
auroc_CI <-  quantile(store_boot$auroc, probs = c(.025,.975))
auprc_CI <- quantile(store_boot$auprc, probs = c(.025,.975))

# map auprc to auroc units
names(empirical_grid)[1] <- "pop_auroc"
auprc_CI_convert <- data.frame(
  point_estimate = auprc_to_auroc(point_auprc, empirical_grid),
  lower_ci = auprc_to_auroc(auprc_CI[1], empirical_grid),
  upper_ci = auprc_to_auroc(auprc_CI[2], empirical_grid)
)

auprc_to_auroc_bias <- auprc_CI_convert$point_estimate - test_auroc$auc

####
# relative difference

# AUPRC is about 75% wider
rel_diff <- (auprc_CI_convert[3] - auprc_CI_convert[2])/(auroc_CI[2] - auroc_CI[1]) - 1

# relative resolving power
relative_width = round(rel_diff,4)
names(relative_width) <- NULL

####
# absolute difference
abs_diff <- (auprc_CI_convert[3] - auprc_CI_convert[2]) - (auroc_CI[2] - auroc_CI[1])



```


```{r empirical simulation results}
bias = round(c(auroc_bias, auprc_bias, auprc_to_auroc_bias),6)

lower_ci = round(c(auroc_CI[1], auprc_CI[1], auprc_CI_convert$lower_ci), 4)
  
upper_ci = round(c(auroc_CI[2], auprc_CI[2], auprc_CI_convert$upper_ci), 4)


sim_results_summary <- data.frame(
  metric = c("AUROC", "AUPRC", "AUPRC to AUROC"),
  #Bias = bias,
  'Lower_CI' = lower_ci,
  'Upper_CI' = upper_ci,
  kappa = upper_ci - lower_ci
)

sim_results_summary$kappa[2] <- NA

sim_results_summary <- sim_results_summary %>% 
  mutate(
    resolving_power = 1/kappa
  )

```


```{r empirical response curve plot}
# point of interest
auroc <- PRROC::roc.curve(scores.class0 = baseline_model$risk_score, weights.class0 = baseline_model$outcome)$auc

auprc <- PRROC::pr.curve(scores.class0 = baseline_model$risk_score, weights.class0 = baseline_model$outcome)$auc.davis.goadrich

baseline_values <- data.frame(auroc=auroc, auprc=auprc)

# create plot
empirical_plot  <- ggplot(empirical_grid, aes(pop_auroc, auprc)) + 
  geom_path() +
  geom_point(data = baseline_values, aes(auroc, auprc), size=2) +
  xlab("AUROC") +
  ylab("AUPRC") +
  #labs(caption = plot_title) +
  theme_bw() +
  theme(plot.caption = element_text(hjust = 0, vjust = 0, size = caption_size))


```


```{r empirical sampling model figure numbers}
# risk distribution plot
fnum_effects <- fnum
fnum <- fnum + 1

# empirical response curve
empirical_fnum <- fnum
fnum <- fnum + 1

```


## Appendix

### A. Linear approximation method for resolving power

```{r response curve derivative}
#----
# deriv_auroc
#
# Return derivative of auroc as function of ausgc
#
## arguments
# 
# ausgc   model ausgc
# v       prevalence of the positive class
#
deriv_auroc <- function(ausgc, v) {
  dydx <- -1/(2*log(v)*ausgc)
  dydx
}

```

```{r alternative resolution definition}
# now plot AUSGC as a function of the AUROC
grid_length <- 1000
prevalence <- 0.01

# evaluation coordinates
auroc_eval <- 0.8
ausgc_eval <- auroc_to_ausgc(auroc_eval, v = prevalence)

# create grid
auroc <- seq(0.5, 1, length.out=grid_length)
ausgc <- auroc_to_ausgc(auroc_quality, v = prevalence)
metric_data <- data.frame(AUROC = auroc, AUSGC = ausgc)

# create tangent line data
auroc_slope <- deriv_auroc(ausgc_eval, v = prevalence)
intercept <- auroc_eval - auroc_slope*ausgc_eval

ausgc_grid <- seq(ausgc_eval - .13, ausgc_eval + .13, length.out= 100)
auroc_grid <- intercept + auroc_slope*ausgc_grid
tangent_data <- data.frame(AUSGC = ausgc_grid, 
                           AUROC = auroc_grid)



####
# alt resolution plot
alt_plot <- ggplot(metric_data, aes(ausgc, auroc)) +
  geom_path(color="black") +
  xlab("AUSGC") +
  ylab("AUROC") +
  geom_point(mapping = aes(ausgc_eval, auroc_eval), data = plot_data, size=3) +
  geom_line(aes(AUSGC, AUROC), data = tangent_data, color="red") +
  theme_bw() +
  NULL

alt_fnum <- fnum

```


### B. Binormal results for different sample sizes

```{r N1k binormal simulation data}
# read-in data
gauss_store <- read_csv("gauss_1000N_10000nsim_3nrepeats.csv")

# find average estimates across runs
gauss_results <- gauss_store %>%
  group_by(prevalence, pop_auroc) %>% 
  summarise(across(everything(), ~mean(.x)) ) %>% 
  select(-nrepeat)

# add population auprc to results
auprc_key <- auprc_grid %>% 
  unite(col = "prev_auroc", prevalence:pop_auroc, sep="_") 

gauss_results <- gauss_results %>% 
  unite(col = "prev_auroc", prevalence:pop_auroc, sep="_", remove=FALSE)

gauss_results <- left_join(gauss_results, auprc_key, "prev_auroc") %>% 
  select(-prev_auroc) %>% 
  rename(pop_auprc = auprc) %>% 
  relocate(pop_auprc, .before = pr_est)

# map auprc to auroc
prevalence <- unique(gauss_results$prevalence)
pr_mean <- NULL
pr_lower <- NULL
pr_upper <- NULL

for(v in prevalence) {
  
  grid_fun <- auprc_grid %>% 
    filter(prevalence==v)
  
  # auprc to auroc: note that it is only to 4-decimal places of precision since grid contains 1000 points
  new_mean <- auprc_to_auroc(gauss_results$pr_est[gauss_results$prevalence==v], grid_fun = grid_fun)
  new_lower <- auprc_to_auroc(gauss_results$pr_est_lower[gauss_results$prevalence==v], grid_fun = grid_fun)
  new_upper <- auprc_to_auroc(gauss_results$pr_est_upper[gauss_results$prevalence==v], grid_fun = grid_fun)
  
  pr_mean <- c(pr_mean, new_mean)
  pr_lower <- c(pr_lower, new_lower)
  pr_upper <- c(pr_upper, new_upper)
  
}

# append to main grid
gauss_results$pr_est_roc <- pr_mean
gauss_results$pr_lower_roc <- pr_lower
gauss_results$pr_upper_roc <- pr_upper

# create data for plotting
plot_data <- gauss_results %>% 
  mutate(
    auroc_bias = roc_est - pop_auroc,
    auprc_bias = pr_est - pop_auprc,
    auprc_roc_bias = pr_est_roc - pop_auroc,
    auroc_CI_width = roc_est_upper - roc_est_lower, 
    auprc_CI_width = pr_upper_roc - pr_lower_roc
  ) %>% 
  select(
    prevalence,
    pop_auroc,
    auroc_bias,
    auprc_bias,
    auprc_roc_bias,
    auroc_CI_width,
    auprc_CI_width
  ) %>% 
  mutate(
    # Use the Hosmer & Lemeshow rule of thumb: https://imaging.mrc-cbu.cam.ac.uk/statswiki/FAQ/roc
    model_quality = case_when(
      pop_auroc==.65 ~ "Poor",
      pop_auroc==.75 ~ "Fair",
      pop_auroc==.85 ~ "Good",
      pop_auroc==.95 ~ "Excellent"
    ),
    model_quality = factor(model_quality, levels = c("Poor", "Fair", "Good", "Excellent")),
    prevalence = factor(prevalence),
    ci_ratio = auprc_CI_width/auroc_CI_width - 1
  )

  

```


```{r N1k results comparison plot}
pop_auroc <- unique(plot_data$pop_auroc)

plot_relative <- ggplot(plot_data, aes(prevalence, ci_ratio, fill=prevalence)) +
  facet_wrap( ~ model_quality, nrow = 1) +
  geom_col() +
  scale_x_discrete(labels = c(".01", ".05", ".10", ".20", ".30", ".40", ".50")) +
  ylab(~ paste(kappa["AUPRC"], "/", kappa["AUROC"], " - 1")) +
  theme_bw()


```


```{r N100k binormal simulation data}
# read-in data
gauss_store <- read_csv("gauss_1e+05N_10000nsim_1nrepeats.csv")

# find average estimates across runs
gauss_results <- gauss_store %>%
  group_by(prevalence, pop_auroc) %>% 
  summarise(across(everything(), ~mean(.x)) ) %>% 
  select(-nrepeat)

# add population auprc to results
auprc_key <- auprc_grid %>% 
  unite(col = "prev_auroc", prevalence:pop_auroc, sep="_") 

gauss_results <- gauss_results %>% 
  unite(col = "prev_auroc", prevalence:pop_auroc, sep="_", remove=FALSE)

gauss_results <- left_join(gauss_results, auprc_key, "prev_auroc") %>% 
  select(-prev_auroc) %>% 
  rename(pop_auprc = auprc) %>% 
  relocate(pop_auprc, .before = pr_est)

# map auprc to auroc
prevalence <- unique(gauss_results$prevalence)
pr_mean <- NULL
pr_lower <- NULL
pr_upper <- NULL

for(v in prevalence) {
  
  grid_fun <- auprc_grid %>% 
    filter(prevalence==v)
  
  # auprc to auroc: note that it is only to 4-decimal places of precision since grid contains 1000 points
  new_mean <- auprc_to_auroc(gauss_results$pr_est[gauss_results$prevalence==v], grid_fun = grid_fun)
  new_lower <- auprc_to_auroc(gauss_results$pr_est_lower[gauss_results$prevalence==v], grid_fun = grid_fun)
  new_upper <- auprc_to_auroc(gauss_results$pr_est_upper[gauss_results$prevalence==v], grid_fun = grid_fun)
  
  pr_mean <- c(pr_mean, new_mean)
  pr_lower <- c(pr_lower, new_lower)
  pr_upper <- c(pr_upper, new_upper)
  
}

# append to main grid
gauss_results$pr_est_roc <- pr_mean
gauss_results$pr_lower_roc <- pr_lower
gauss_results$pr_upper_roc <- pr_upper

# create data for plotting
plot_data <- gauss_results %>% 
  mutate(
    auroc_bias = roc_est - pop_auroc,
    auprc_bias = pr_est - pop_auprc,
    auprc_roc_bias = pr_est_roc - pop_auroc,
    auroc_CI_width = roc_est_upper - roc_est_lower, 
    auprc_CI_width = pr_upper_roc - pr_lower_roc
  ) %>% 
  select(
    prevalence,
    pop_auroc,
    auroc_bias,
    auprc_bias,
    auprc_roc_bias,
    auroc_CI_width,
    auprc_CI_width
  ) %>% 
  mutate(
    # Use the Hosmer & Lemeshow rule of thumb: https://imaging.mrc-cbu.cam.ac.uk/statswiki/FAQ/roc
    model_quality = case_when(
      pop_auroc==.65 ~ "Poor",
      pop_auroc==.75 ~ "Fair",
      pop_auroc==.85 ~ "Good",
      pop_auroc==.95 ~ "Excellent"
    ),
    model_quality = factor(model_quality, levels = c("Poor", "Fair", "Good", "Excellent")),
    prevalence = factor(prevalence),
    ci_ratio = auprc_CI_width/auroc_CI_width - 1
  )

  

```

```{r N100k results comparison plot}
pop_auroc <- unique(plot_data$pop_auroc)

plot_relative <- ggplot(plot_data, aes(prevalence, ci_ratio, fill=prevalence)) +
  facet_wrap( ~ model_quality, nrow = 1) +
  geom_col() +
  scale_x_discrete(labels = c(".01", ".05", ".10", ".20", ".30", ".40", ".50")) +
  ylab(~ paste(kappa["AUPRC"], "/", kappa["AUROC"], " - 1")) +
  theme_bw()

```


```{r appendix B figure numbers}
N1k_results_fnum <- fnum
fnum <- fnum+1

N100k_results_fnum <- fnum
fnum <- fnum+1

```

